# Workout Session Provider Implementation Briefing

## Mission
Port workout session management from MainViewModel.kt (lines 57-1155, ~1000 lines) to a focused Riverpod provider. This provider manages the workout state machine, rep counting, timers, metrics collection, and workout lifecycle.

## Source Reference
**Kotlin File:** `C:\Users\dasbl\AndroidStudioProjects\VitruvianRedux\app\src\main\java\com\example\vitruvianredux\presentation\viewmodel\MainViewModel.kt`
**Lines:** 57-1155 (workout session logic)
**Analysis:** `WORKOUT_ANALYSIS.md` (441 lines, complete breakdown)

## Target File
**Path:** `lib/presentation/providers/workout_session_provider.dart`
**Estimated Size:** ~500-600 lines
**Complexity:** HIGHEST (state machine, timers, rep counting integration)

## State to Manage

Based on MainViewModel.kt analysis, manage these properties:

### Core StateFlows (11 total)

#### 1. Workout State (9-state machine)
```kotlin
// Lines 57-58 - MainViewModel.kt
val workoutState: StateFlow<WorkoutState>
```

**States:**
- `Idle` - Initial state, awaiting start
- `Countdown(secondsRemaining)` - Pre-workout countdown (5→1)
- `Active` - Workout in progress, rep counting enabled
- `SetSummary(metrics, peakPower, averagePower, repCount)` - Post-set metrics display
- `Resting(restSecondsRemaining, nextExerciseName, isLastExercise, currentSet, totalSets)` - Rest between sets
- `Paused` - Workout paused (rarely used)
- `Completed` - Final state (normal workouts)
- `Error(message)` - Unrecoverable error
- `Initializing` - Transient preparation state

**State Transitions:**
```
Normal Flow:
  Idle → Countdown(5→1) → Active → SetSummary → Resting(90→1) → Active → ... → Completed

Just Lift Flow:
  Idle → AutoStart(3→1) → Active → SetSummary → Idle (auto-reset!)
```

**Dart equivalent:**
```dart
@freezed
class WorkoutState with _$WorkoutState {
  const factory WorkoutState.idle() = Idle;
  const factory WorkoutState.countdown({required int secondsRemaining}) = Countdown;
  const factory WorkoutState.active() = Active;
  const factory WorkoutState.setSummary({
    required List<WorkoutMetric> metrics,
    required double peakPower,
    required double averagePower,
    required int repCount,
  }) = SetSummary;
  const factory WorkoutState.resting({
    required int restSecondsRemaining,
    required String nextExerciseName,
    required bool isLastExercise,
    required int currentSet,
    required int totalSets,
  }) = Resting;
  const factory WorkoutState.paused() = Paused;
  const factory WorkoutState.completed() = Completed;
  const factory WorkoutState.error({required String message}) = WorkoutError;
  const factory WorkoutState.initializing() = Initializing;
}
```

#### 2. Current Metric (Real-time position/load data)
```kotlin
// Lines 60-61
val currentMetric: StateFlow<WorkoutMetric?>
```

**Dart:**
```dart
WorkoutMetric? get currentMetric => state.currentMetric;
```

#### 3. Workout Parameters
```kotlin
// Lines 63-74
val workoutParameters: StateFlow<WorkoutParameters>
// Fields: workoutType, reps, weightPerCableKg, progressionRegressionKg,
//         isJustLift, useAutoStart, stopAtTop, warmupReps, selectedExerciseId
```

#### 4. Rep Count
```kotlin
// Lines 76-77
val repCount: StateFlow<RepCount>
// Fields: warmupReps, workingReps, totalReps, isWarmupComplete
```

#### 5. Rep Ranges (ROM visualization boundaries)
```kotlin
// Lines 79-80
val repRanges: StateFlow<RepRanges?>
```

#### 6. Auto-Stop State (Just Lift 3-second timer)
```kotlin
// Lines 82-83
val autoStopState: StateFlow<AutoStopUiState>
// Fields: isActive (Bool), progress (0-1), secondsRemaining (Int)
```

**Dart:**
```dart
@freezed
class AutoStopUiState with _$AutoStopUiState {
  const factory AutoStopUiState({
    @Default(false) bool isActive,
    @Default(0.0) double progress,
    @Default(0) int secondsRemaining,
  }) = _AutoStopUiState;
}
```

#### 7. Auto-Start Countdown (Grab-to-start 3s timer)
```kotlin
// Lines 85-86
val autoStartCountdown: StateFlow<Int?>
```

#### 8. Routine Management Indices
```kotlin
// Lines 118, 121, 124
val loadedRoutine: StateFlow<Routine?>
val currentExerciseIndex: StateFlow<Int>
val currentSetIndex: StateFlow<Int>
```

#### 9. Connection Lost Flag
```kotlin
// Line 253
val connectionLostDuringWorkout: StateFlow<Boolean>
```

### Event Streams (2 SharedFlows)

#### 1. Haptic Events
```kotlin
// Lines 246-250
val hapticEvents: SharedFlow<HapticEvent>
// Events: REP_COMPLETED, WARMUP_COMPLETE, WORKOUT_COMPLETE,
//         WORKOUT_START, WORKOUT_END, ERROR
```

**Dart:** Already implemented in `haptic_provider.dart`, reference via `HapticActions`

#### 2. PR Celebration Events
```kotlin
// Lines 95-96
val prCelebrationEvent: SharedFlow<PRCelebrationEvent>
```

**Dart:**
```dart
final _prCelebrationController = StreamController<PRCelebrationEvent>.broadcast();
Stream<PRCelebrationEvent> get prCelebrationEvents => _prCelebrationController.stream;
```

## Workout Session State Model

Create a freezed state class to hold all workout session state:

```dart
import 'package:freezed_annotation/freezed_annotation.dart';
import '../../domain/models/workout_state.dart';
import '../../domain/models/workout_parameters.dart';
import '../../domain/models/rep_count.dart';
import '../../domain/models/rep_ranges.dart';
import '../../domain/models/workout_metric.dart';
import '../../domain/models/routine.dart';

part 'workout_session_state.freezed.dart';

@freezed
class WorkoutSessionState with _$WorkoutSessionState {
  const factory WorkoutSessionState({
    @Default(WorkoutState.idle()) WorkoutState workoutState,
    WorkoutMetric? currentMetric,
    required WorkoutParameters workoutParameters,
    @Default(RepCount()) RepCount repCount,
    RepRanges? repRanges,
    @Default(AutoStopUiState()) AutoStopUiState autoStopState,
    int? autoStartCountdown,
    Routine? loadedRoutine,
    @Default(0) int currentExerciseIndex,
    @Default(0) int currentSetIndex,
    @Default(false) bool connectionLostDuringWorkout,

    // Internal state (not exposed in Kotlin but needed)
    String? currentSessionId,
    int? workoutStartTime,
    @Default([]) List<WorkoutMetric> collectedMetrics,
  }) = _WorkoutSessionState;
}
```

## Key Methods to Implement (13 methods)

### 1. startWorkout (Lines 733-817)
```kotlin
fun startWorkout(skipCountdown: Boolean = false, isJustLiftMode: Boolean = false)
```

**State Flow:** `(Optional Countdown 5→1) → Active`

**Logic:**
1. If skipCountdown=false AND NOT Just Lift:
   - Emit Countdown(5), delay 1s
   - Emit Countdown(4), delay 1s
   - ... Countdown(1), delay 1s
2. Reset rep counter with config (warmup=3, working=reps, isJustLift, stopAtTop)
3. Generate session UUID
4. Record start timestamp
5. Clear collected metrics
6. Send BLE start command (via BleRepository)
7. Start foreground service (Android only - skip in Flutter)
8. Transition to Active state
9. Emit WORKOUT_START haptic

**Dart pattern:**
```dart
Future<void> startWorkout({
  bool skipCountdown = false,
  bool isJustLiftMode = false,
}) async {
  final params = state.workoutParameters;

  // Pre-workout countdown
  if (!skipCountdown && !params.isJustLift) {
    for (int i = 5; i >= 1; i--) {
      state = state.copyWith(
        workoutState: WorkoutState.countdown(secondsRemaining: i),
      );
      await Future.delayed(Duration(seconds: 1));
    }
  }

  // Reset rep counter
  final workingTarget = isJustLiftMode ? 0 : params.reps;
  _repCounter.reset();
  _repCounter.configure(
    warmupTarget: params.warmupReps,
    workingTarget: workingTarget,
    isJustLift: params.isJustLift,
    stopAtTop: params.stopAtTop,
  );

  // Session tracking
  final sessionId = Uuid().v4();
  final startTime = DateTime.now().millisecondsSinceEpoch;

  state = state.copyWith(
    currentSessionId: sessionId,
    workoutStartTime: startTime,
    collectedMetrics: [],
    workoutState: WorkoutState.active(),
  );

  // Start BLE monitoring
  final result = await _bleRepository.startWorkout();
  result.fold(
    (error) {
      state = state.copyWith(
        workoutState: WorkoutState.error(message: error.toString()),
      );
    },
    (_) {
      _hapticActions.onWorkoutStart();
      _startMonitoringMetrics();
    },
  );
}
```

### 2. stopWorkout (Lines 819-865)
```kotlin
fun stopWorkout()
```

**State Flow:** `Any active state → Completed`

**Logic:**
1. Cancel all timers (rest, auto-start, auto-stop)
2. Send BLE stop command
3. Save workout session to database
4. Reset rep counter
5. Transition to Completed
6. Emit WORKOUT_END haptic
7. Stop foreground service (skip in Flutter)

**Dart:**
```dart
Future<void> stopWorkout() async {
  // Cancel timers
  _autoStartTimer?.cancel();
  _restTimer?.cancel();
  _autoStopTimer?.cancel();

  // Stop BLE
  await _bleRepository.stopWorkout();

  // Save session
  await _saveWorkoutSession();

  // Reset state
  _repCounter.reset();
  state = state.copyWith(
    workoutState: WorkoutState.completed(),
  );

  _hapticActions.onWorkoutEnd();
}
```

### 3. handleSetCompletion (Lines 888-928)
```kotlin
fun handleSetCompletion()
```

**Trigger:** Auto-stop triggered (3s in danger zone for Just Lift) OR rep target reached

**State Flow:** `Active → SetSummary`

**Logic:**
1. Calculate metrics (peak power, average power, total reps)
2. Transition to SetSummary with calculated data
3. Emit WORKOUT_END haptic

**Dart:**
```dart
Future<void> handleSetCompletion() async {
  final metrics = state.collectedMetrics;

  // Calculate summary metrics
  final peakPower = _metricsCalculator.calculatePeakPower(metrics);
  final averagePower = _metricsCalculator.calculateAveragePower(metrics);
  final repCount = state.repCount.totalReps;

  state = state.copyWith(
    workoutState: WorkoutState.setSummary(
      metrics: metrics,
      peakPower: peakPower,
      averagePower: averagePower,
      repCount: repCount,
    ),
  );

  _hapticActions.onWorkoutEnd();
}
```

### 4. proceedFromSummary (Lines 946-1018)
```kotlin
fun proceedFromSummary()
```

**Decision Logic:**
- If Just Lift: → Idle (auto-reset)
- If more sets/exercises in routine: → startRestTimer()
- Else: → Completed

**Dart:**
```dart
Future<void> proceedFromSummary() async {
  final params = state.workoutParameters;

  // Just Lift auto-resets to Idle
  if (params.isJustLift) {
    state = state.copyWith(workoutState: WorkoutState.idle());
    return;
  }

  // Check if more sets/exercises
  final routine = state.loadedRoutine;
  if (routine != null && _hasMoreSetsOrExercises()) {
    await startRestTimer();
  } else {
    state = state.copyWith(workoutState: WorkoutState.completed());
  }
}
```

### 5. startRestTimer (Lines 1043-1155)
```kotlin
fun startRestTimer()
```

**Duration:** exercise.restSeconds OR 90s default

**State Flow:** `→ Resting(countdown) → ... → Resting(0)`

**Auto-Advance:** If `userPreferences.autoplayEnabled`, automatically call `startNextSetOrExercise()` when timer reaches 0

**Dart:**
```dart
Future<void> startRestTimer() async {
  final routine = state.loadedRoutine;
  final exerciseIndex = state.currentExerciseIndex;
  final exercise = routine?.exercises[exerciseIndex];
  final restDuration = exercise?.restSeconds ?? 90;

  final nextExercise = _getNextExerciseName();
  final isLastExercise = _isLastExercise();
  final currentSet = state.currentSetIndex + 1;
  final totalSets = exercise?.sets ?? 1;

  state = state.copyWith(
    workoutState: WorkoutState.resting(
      restSecondsRemaining: restDuration,
      nextExerciseName: nextExercise,
      isLastExercise: isLastExercise,
      currentSet: currentSet,
      totalSets: totalSets,
    ),
  );

  // Countdown timer
  _restTimer = Timer.periodic(Duration(seconds: 1), (timer) async {
    final currentState = state.workoutState;
    if (currentState is Resting) {
      final remaining = currentState.restSecondsRemaining - 1;

      if (remaining <= 0) {
        timer.cancel();

        // Auto-advance if enabled
        final prefs = await ref.read(userPreferencesProvider.future);
        if (prefs.autoplayEnabled) {
          await startNextSetOrExercise();
        } else {
          // Stay in Resting(0) waiting for manual skipRest()
          state = state.copyWith(
            workoutState: currentState.copyWith(restSecondsRemaining: 0),
          );
        }
      } else {
        state = state.copyWith(
          workoutState: currentState.copyWith(restSecondsRemaining: remaining),
        );
      }
    }
  });
}
```

### 6. skipRest (Lines 1240-1267)
```kotlin
fun skipRest()
```

**Action:** Cancel rest timer, immediately start next set/exercise

**Dart:**
```dart
Future<void> skipRest() async {
  _restTimer?.cancel();
  _restTimer = null;
  await startNextSetOrExercise();
}
```

### 7. startNextSetOrExercise (Lines 1157-1238)
```kotlin
fun startNextSetOrExercise()
```

**State Guard:** ONLY callable from Resting state (line 1165)

**Logic:**
1. Increment set index
2. If set index > exercise sets: move to next exercise, reset set index
3. If no more exercises: call stopWorkout()
4. Update workout parameters with new exercise
5. Call startWorkout(skipCountdown=true)

**Dart:**
```dart
Future<void> startNextSetOrExercise() async {
  final currentState = state.workoutState;
  if (currentState is! Resting) {
    logger.w('startNextSetOrExercise called from non-Resting state');
    return;
  }

  final routine = state.loadedRoutine;
  if (routine == null) {
    await stopWorkout();
    return;
  }

  var setIndex = state.currentSetIndex + 1;
  var exerciseIndex = state.currentExerciseIndex;

  final currentExercise = routine.exercises[exerciseIndex];

  // Move to next exercise?
  if (setIndex >= currentExercise.sets) {
    setIndex = 0;
    exerciseIndex++;
  }

  // No more exercises?
  if (exerciseIndex >= routine.exercises.length) {
    await stopWorkout();
    return;
  }

  // Update indices
  state = state.copyWith(
    currentSetIndex: setIndex,
    currentExerciseIndex: exerciseIndex,
  );

  // Update parameters for new exercise
  final nextExercise = routine.exercises[exerciseIndex];
  state = state.copyWith(
    workoutParameters: state.workoutParameters.copyWith(
      selectedExerciseId: nextExercise.exerciseId,
      reps: nextExercise.reps,
      weightPerCableKg: nextExercise.weightPerCableKg,
    ),
  );

  await startWorkout(skipCountdown: true);
}
```

### 8. handleMonitorMetric (Lines 450-462)
```kotlin
fun handleMonitorMetric(metric: WorkoutMetric)
```

**Logic:**
1. Update currentMetric
2. If Active state: add to collectedMetrics
3. If Just Lift: check auto-stop timer
4. Else: reset auto-stop timer

**Dart:**
```dart
void handleMonitorMetric(WorkoutMetric metric) {
  state = state.copyWith(currentMetric: metric);

  final currentState = state.workoutState;
  if (currentState is Active) {
    // Collect metrics
    final updated = List<WorkoutMetric>.from(state.collectedMetrics)..add(metric);
    state = state.copyWith(collectedMetrics: updated);

    // Check auto-stop for Just Lift
    if (state.workoutParameters.isJustLift) {
      _checkAutoStop(metric);
    } else {
      _resetAutoStopTimer();
    }
  }
}
```

### 9. handleRepNotification (Lines 467-478)
```kotlin
fun handleRepNotification(notification: RepNotification)
```

**Logic:**
1. Feed data to RepCounter
2. Update rep ranges for visualization

**Dart:**
```dart
void handleRepNotification(RepNotification notification) {
  _repCounter.process(
    topCounter: notification.topCounter,
    completeCounter: notification.completeCounter,
    posA: state.currentMetric?.positionA,
    posB: state.currentMetric?.positionB,
  );

  state = state.copyWith(
    repRanges: _repCounter.getRepRanges(),
  );
}
```

### 10. checkAutoStop (Lines 495-529)
```kotlin
fun checkAutoStop(metric: WorkoutMetric)
```

**Just Lift Auto-Stop Timer Logic:**

**Trigger:** Position in danger zone (detected by RepCounterFromMachine)

**Duration:** 3 seconds exactly

**Visual:** Progress bar (0.0 → 1.0)

**Double-Trigger Prevention:** Use atomic flags

**Dart:**
```dart
void _checkAutoStop(WorkoutMetric metric) {
  final inDangerZone = _repCounter.isInDangerZone();

  if (inDangerZone && !_autoStopTriggered) {
    _autoStopStartTime ??= DateTime.now();

    final elapsed = DateTime.now().difference(_autoStopStartTime!).inMilliseconds / 1000.0;
    final progress = (elapsed / 3.0).clamp(0.0, 1.0);
    final secondsRemaining = max(0, 3 - elapsed.ceil());

    state = state.copyWith(
      autoStopState: AutoStopUiState(
        isActive: true,
        progress: progress,
        secondsRemaining: secondsRemaining,
      ),
    );

    // Trigger after 3 seconds
    if (elapsed >= 3.0 && !_autoStopStopRequested) {
      _autoStopTriggered = true;
      _autoStopStopRequested = true;
      handleSetCompletion();
    }
  } else if (!inDangerZone) {
    _resetAutoStopTimer();
  }
}

void _resetAutoStopTimer() {
  _autoStopStartTime = null;
  _autoStopTriggered = false;
  _autoStopStopRequested = false;

  state = state.copyWith(
    autoStopState: AutoStopUiState(),
  );
}
```

### 11. startAutoStartTimer (Lines 428-448)
```kotlin
fun startAutoStartTimer()
```

**Grab-to-Start 3-second Countdown**

**Trigger:** Handle grab + useAutoStart=true + Idle state

**Visual:** Countdown 3→2→1

**Calls:** `startWorkout(isJustLiftMode=true)` after 3 seconds

**Dart:**
```dart
void startAutoStartTimer() {
  if (state.workoutState is! Idle) return;
  if (!state.workoutParameters.useAutoStart) return;

  state = state.copyWith(autoStartCountdown: 3);

  _autoStartTimer = Timer.periodic(Duration(seconds: 1), (timer) {
    final countdown = state.autoStartCountdown;
    if (countdown == null) {
      timer.cancel();
      return;
    }

    final next = countdown - 1;
    if (next <= 0) {
      timer.cancel();
      state = state.copyWith(autoStartCountdown: null);
      startWorkout(isJustLiftMode: true);
    } else {
      state = state.copyWith(autoStartCountdown: next);
    }
  });
}

void cancelAutoStartTimer() {
  _autoStartTimer?.cancel();
  _autoStartTimer = null;
  state = state.copyWith(autoStartCountdown: null);
}
```

### 12. resetForNewWorkout (Lines 1452-1459)
```kotlin
fun resetForNewWorkout()
```

**Reset state to Idle without disconnecting BLE**

**Dart:**
```dart
void resetForNewWorkout() {
  _repCounter.reset();
  state = state.copyWith(
    workoutState: WorkoutState.idle(),
    repCount: RepCount(),
    repRanges: null,
    currentExerciseIndex: 0,
    currentSetIndex: 0,
    autoStopState: AutoStopUiState(),
  );
}
```

### 13. loadRoutine (Lines 1525-1568)
```kotlin
fun loadRoutine(routine: Routine)
```

**CRITICAL:** Set isJustLift=false (line 1556)

**Dart:**
```dart
void loadRoutine(Routine routine) {
  state = state.copyWith(
    loadedRoutine: routine,
    currentExerciseIndex: 0,
    currentSetIndex: 0,
    workoutParameters: state.workoutParameters.copyWith(
      isJustLift: false,
      selectedExerciseId: routine.exercises.first.exerciseId,
      reps: routine.exercises.first.reps,
      weightPerCableKg: routine.exercises.first.weightPerCableKg,
    ),
  );
}
```

## Rep Counter Integration

**CRITICAL:** RepCounterFromMachine must be ported separately or stubbed

**Setup Callback (init block, lines 277-310):**
```dart
class WorkoutSessionNotifier extends StateNotifier<WorkoutSessionState> {
  WorkoutSessionNotifier(/* deps */) : super(WorkoutSessionState(/* initial */)) {
    // Setup rep event callback
    _repCounter.onRepEvent = (RepEvent event) {
      final newRepCount = _repCounter.getRepCount();
      state = state.copyWith(repCount: newRepCount);

      // Emit haptic feedback
      switch (event) {
        case RepEvent.warmupCompleted:
        case RepEvent.workingCompleted:
          _hapticActions.onRepCompleted();
          break;
        case RepEvent.warmupComplete:
          _hapticActions.emitHaptic(HapticEvent.warmupComplete);
          break;
        case RepEvent.workoutComplete:
          _hapticActions.emitHaptic(HapticEvent.workoutComplete);
          break;
      }

      // Check if should stop
      if (_repCounter.shouldStopWorkout()) {
        handleSetCompletion();
      }
    };
  }
}
```

## Dependencies

**Already available:**
- BleRepository (Phase 3)
- WorkoutSessionDao (Phase 3)
- PreferencesManager (Phase 3)
- HapticActions (Phase 4.1)
- MetricsCalculator (may need to create stub)

**Need to create/stub:**
- RepCounterFromMachine (complex, can stub for now with TODO)
- WorkoutState domain model (freezed)
- WorkoutParameters domain model (freezed, may exist)
- RepCount domain model (freezed, may exist)
- RepRanges domain model (freezed)
- AutoStopUiState domain model (freezed)
- PRCelebrationEvent domain model (freezed)

**Packages:**
- flutter_riverpod: ^2.6.1 ✅
- logger: ^2.4.0 ✅
- freezed_annotation: ^2.5.7 ✅
- uuid: ^4.5.1 (for session ID generation)

## Provider Structure

```dart
import 'dart:async';
import 'dart:math';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:logger/logger.dart';
import 'package:uuid/uuid.dart';
import '../../data/repositories/ble_repository.dart';
import '../../data/database/daos/workout_session_dao.dart';
import '../../domain/models/workout_state.dart';
import '../../domain/models/workout_parameters.dart';
import '../../domain/models/rep_count.dart';
import '../../domain/models/workout_metric.dart';
import '../../domain/models/routine.dart';
import '../../domain/services/rep_counter_from_machine.dart';
import '../../domain/services/metrics_calculator.dart';
import 'workout_session_state.dart';
import 'preferences_provider.dart';
import 'haptic_provider.dart';

final logger = Logger();

/// StateNotifier for workout session management
class WorkoutSessionNotifier extends StateNotifier<WorkoutSessionState> {
  final BleRepository _bleRepository;
  final WorkoutSessionDao _workoutSessionDao;
  final RepCounterFromMachine _repCounter;
  final MetricsCalculator _metricsCalculator;
  final HapticActions _hapticActions;
  final Ref _ref;

  Timer? _autoStartTimer;
  Timer? _restTimer;
  Timer? _autoStopTimer;

  DateTime? _autoStopStartTime;
  bool _autoStopTriggered = false;
  bool _autoStopStopRequested = false;

  StreamController<PRCelebrationEvent>? _prCelebrationController;
  Stream<PRCelebrationEvent> get prCelebrationEvents =>
      _prCelebrationController?.stream ?? Stream.empty();

  WorkoutSessionNotifier(
    this._bleRepository,
    this._workoutSessionDao,
    this._repCounter,
    this._metricsCalculator,
    this._hapticActions,
    this._ref,
  ) : super(WorkoutSessionState(
        workoutParameters: WorkoutParameters(/* defaults */),
      )) {
    _prCelebrationController = StreamController<PRCelebrationEvent>.broadcast();
    _setupRepCounterCallback();
  }

  void _setupRepCounterCallback() {
    _repCounter.onRepEvent = (RepEvent event) {
      // Implementation from section above
    };
  }

  // All 13 methods here...

  @override
  void dispose() {
    _autoStartTimer?.cancel();
    _restTimer?.cancel();
    _autoStopTimer?.cancel();
    _prCelebrationController?.close();
    super.dispose();
  }
}

/// Provider for workout session notifier
final workoutSessionProvider = StateNotifierProvider<WorkoutSessionNotifier, WorkoutSessionState>((ref) {
  final bleRepo = ref.watch(bleRepositoryProvider);
  final workoutDao = ref.watch(workoutSessionDaoProvider);
  final repCounter = ref.watch(repCounterProvider);
  final metricsCalc = ref.watch(metricsCalculatorProvider);
  final hapticActions = ref.watch(hapticActionsProvider);

  return WorkoutSessionNotifier(
    bleRepo,
    workoutDao,
    repCounter,
    metricsCalc,
    hapticActions,
    ref,
  );
});

/// Actions provider for workout operations
final workoutSessionActionsProvider = Provider<WorkoutSessionActions>((ref) {
  final notifier = ref.watch(workoutSessionProvider.notifier);
  return WorkoutSessionActions(notifier);
});

class WorkoutSessionActions {
  final WorkoutSessionNotifier _notifier;

  WorkoutSessionActions(this._notifier);

  Future<void> startWorkout({bool skipCountdown = false, bool isJustLiftMode = false}) =>
      _notifier.startWorkout(skipCountdown: skipCountdown, isJustLiftMode: isJustLiftMode);

  Future<void> stopWorkout() => _notifier.stopWorkout();
  Future<void> proceedFromSummary() => _notifier.proceedFromSummary();
  Future<void> skipRest() => _notifier.skipRest();
  void handleMonitorMetric(WorkoutMetric metric) => _notifier.handleMonitorMetric(metric);
  void handleRepNotification(RepNotification notification) =>
      _notifier.handleRepNotification(notification);
  void startAutoStartTimer() => _notifier.startAutoStartTimer();
  void cancelAutoStartTimer() => _notifier.cancelAutoStartTimer();
  void resetForNewWorkout() => _notifier.resetForNewWorkout();
  void loadRoutine(Routine routine) => _notifier.loadRoutine(routine);
}
```

## Validation Checklist

- [ ] WorkoutSessionState freezed class created
- [ ] WorkoutState sealed freezed class with 9 states
- [ ] AutoStopUiState freezed class
- [ ] All 13 methods implemented
- [ ] 4 timer types implemented (auto-start, countdown, auto-stop, rest)
- [ ] Rep counter callback setup
- [ ] State machine transitions correct
- [ ] Just Lift unique behavior (auto-reset to Idle, not Completed)
- [ ] Double-trigger prevention for auto-stop
- [ ] State guards (startNextSetOrExercise only from Resting)
- [ ] Timer cleanup in dispose()
- [ ] Haptic event integration
- [ ] PR celebration event stream
- [ ] Metrics collection during Active state
- [ ] Session persistence (saveWorkoutSession stub OK for now)
- [ ] `flutter pub run build_runner build` for freezed generation
- [ ] `flutter analyze lib/presentation/providers/workout_session_provider.dart` passes

## Critical Implementation Notes

1. **Just Lift Auto-Reset:** Line 1006 - Must transition to Idle (NOT Completed) after Just Lift set summary
2. **State Guards:** startNextSetOrExercise only callable from Resting state
3. **Double-Trigger Prevention:** Use boolean flags for auto-stop
4. **Timer Durations:**
   - Auto-start hold: 3 seconds
   - Pre-workout countdown: 5 seconds
   - Auto-stop: 3 seconds
   - Rest: configurable, default 90 seconds
5. **Rep Counter:** Can stub with TODO for now if RepCounterFromMachine not ready
6. **Metrics Calculator:** Can stub with simple peak/average calculations
7. **Session Persistence:** Can stub _saveWorkoutSession() with TODO

## Success Criteria

1. All 13 workout methods ported and functional
2. 9-state machine correctly implemented with proper transitions
3. 4 timer types working (countdown, auto-start, auto-stop, rest)
4. Rep counter integration (even if stubbed)
5. Freezed code generation successful
6. Zero blocking compilation errors
7. Matches Kotlin behavior for state transitions
8. Just Lift unique flow preserved (auto-reset to Idle)
9. Proper timer cleanup in dispose()

## Notes

- This is the most complex provider in Phase 4
- RepCounterFromMachine may need separate porting effort
- MetricsCalculator can be stubbed with simple calculations
- Session persistence can be stubbed initially
- Focus on state machine correctness first, then timer logic
- Just Lift flow is unique and must auto-reset to Idle
