# Flutter UI Features Implementation Briefing

## Priority 1: Vertical Cable Position Indicator Bars

### Objective
Create `cable_position_indicator.dart` widget that shows vertical bars for cable positions during active workouts.

### Source Reference (Kotlin WorkoutTab.kt lines 1687-1793)

**Key Specifications:**
- Widget Name: `VerticalCablePositionBar`
- Parameters: `label`, `currentPosition` (0-1000), `minPosition?`, `maxPosition?`, `isActive`
- Width: 40dp fixed
- Height: fills available space
- Rounded corners: 20dp radius
- Background: surfaceVariant color

### Flutter Implementation

**File:** `lib/presentation/widgets/workout/cable_position_indicator.dart`

**Widget Structure:**
```dart
class CablePositionIndicator extends StatelessWidget {
  final String label;              // "L" or "R"
  final int currentPosition;       // 0-1000
  final int? minPosition;          // Optional min for range
  final int? maxPosition;          // Optional max for range
  final bool isActive;             // Active workout state

  const CablePositionIndicator({
    required this.label,
    required this.currentPosition,
    this.minPosition,
    this.maxPosition,
    required this.isActive,
    super.key,
  });
}
```

### Layout Structure (from top to bottom)

1. **Label Text**
   - Style: `textTheme.labelSmall` with `FontWeight.bold`
   - Color: `colorScheme.primary` (active) or `colorScheme.onSurfaceVariant` (inactive)
   - Padding: 4dp bottom

2. **Bar Container** (LayoutBuilder to get height)
   - Width: 40dp
   - Height: Expanded/flexible to fill available space
   - Shape: `RoundedRectangleBorder(borderRadius: 20dp)`
   - Background: `colorScheme.surfaceVariant`

3. **Bar Layers** (render order bottom-to-top):

   **Layer 1: Range Zone (if min/max provided)**
   - Height: `barHeight * (maxProgress - minProgress)`
   - Position: Align bottom with offset `y = -barHeight * minProgress`
   - Color: `colorScheme.primary.withOpacity(0.3)`

   **Layer 2: Current Position Fill**
   - Height: `barHeight * currentProgress`
   - Position: Align to bottom
   - Color:
     - Active: `colorScheme.primary`
     - Inactive: `colorScheme.outline.withOpacity(0.5)`

   **Layer 3: Range Markers** (2dp horizontal lines)
   - Min marker: Height 2dp, positioned at `y = -barHeight * minProgress`
   - Max marker: Height 2dp, positioned at `y = -barHeight * maxProgress`
   - Color: `colorScheme.primary.withOpacity(0.6)`

4. **Position Value Text**
   - Text: `"${currentPosition / 10}%"` (convert 0-1000 to 0-100%)
   - Style: `textTheme.labelSmall`
   - Color: Same as label (primary/onSurfaceVariant based on isActive)
   - Padding: 4dp top

### Calculations

```dart
const maxPos = 1000;
final currentProgress = (currentPosition / maxPos).clamp(0.0, 1.0);
final minProgress = minPosition != null ? (minPosition! / maxPos).clamp(0.0, 1.0) : null;
final maxProgress = maxPosition != null ? (maxPosition! / maxPos).clamp(0.0, 1.0) : null;
```

### Implementation Notes

1. Use `LayoutBuilder` inside the bar container to get `maxHeight`
2. Use `Stack` with `Align` for positioning layers
3. Use `Transform.translate` for offset positioning if needed
4. Ensure all layers align to `Alignment.bottomCenter`
5. Render range zone only if `minProgress != null && maxProgress != null && maxProgress > minProgress`
6. Render markers only if min/max are available

### Usage Example

```dart
// In active_workout_screen.dart
Row(
  mainAxisAlignment: MainAxisAlignment.spaceBetween,
  children: [
    SizedBox(
      width: 40,
      child: CablePositionIndicator(
        label: 'L',
        currentPosition: metrics.positionA,
        minPosition: calibration?.minPositionA,
        maxPosition: calibration?.maxPositionA,
        isActive: isActive,
      ),
    ),
    Expanded(child: /* center content */),
    SizedBox(
      width: 40,
      child: CablePositionIndicator(
        label: 'R',
        currentPosition: metrics.positionB,
        minPosition: calibration?.minPositionB,
        maxPosition: calibration?.maxPositionB,
        isActive: isActive,
      ),
    ),
  ],
)
```

---

## Priority 2: Force Graph in Set Summary Card

### Objective
Add force/time graph to `SetSummaryCard` widget using fl_chart package.

### Source Reference (Kotlin SetSummaryCard.kt lines 187-265)

**Key Specifications:**
- Uses MPAndroidChart LineChart (we'll use fl_chart in Flutter)
- Shows force over time with cubic bezier interpolation
- X-axis: Time in seconds
- Y-axis: Total load (force)
- Purple line (#9333EA) with fill, 2px width
- No circle markers on points
- Height: 200dp

### Flutter Implementation

**Update File:** `lib/presentation/widgets/workout/set_summary_card.dart`

**Add after the stats cards, before the Continue button:**

```dart
// Force Graph
if (metrics.isNotEmpty) {
  Text(
    'Force Over Time',
    style: Theme.of(context).textTheme.titleMedium?.copyWith(
      fontWeight: FontWeight.w600,
    ),
  ),
  const SizedBox(height: 8),
  SizedBox(
    height: 200,
    child: ForceGraph(metrics: metrics),
  ),
}
```

**Create ForceGraph widget:**

```dart
class ForceGraph extends StatelessWidget {
  final List<WorkoutMetric> metrics;

  const ForceGraph({required this.metrics, super.key});

  @override
  Widget build(BuildContext context) {
    if (metrics.isEmpty) return const SizedBox.shrink();

    final startTime = metrics.first.timestamp;
    final spots = metrics.map((metric) {
      final elapsedSeconds = (metric.timestamp - startTime) / 1000.0;
      return FlSpot(elapsedSeconds, metric.totalLoad.toDouble());
    }).toList();

    return LineChart(
      LineChartData(
        gridData: FlGridData(show: true),
        titlesData: FlTitlesData(
          leftTitles: AxisTitles(
            sideTitles: SideTitles(showTitles: true),
          ),
          bottomTitles: AxisTitles(
            sideTitles: SideTitles(
              showTitles: true,
              getTitlesWidget: (value, meta) {
                return Text('${value.toInt()}s');
              },
            ),
          ),
          rightTitles: AxisTitles(sideTitles: SideTitles(showTitles: false)),
          topTitles: AxisTitles(sideTitles: SideTitles(showTitles: false)),
        ),
        borderData: FlBorderData(show: false),
        lineBarsData: [
          LineChartBarData(
            spots: spots,
            isCurved: true,
            curveSmoothness: 0.4,
            color: const Color(0xFF9333EA), // Purple
            barWidth: 2,
            dotData: FlDotData(show: false),
            belowBarData: BarAreaData(
              show: true,
              color: const Color(0xFF9333EA).withOpacity(0.2),
            ),
          ),
        ],
      ),
    );
  }
}
```

### Implementation Notes

1. Add `fl_chart` import to set_summary_card.dart
2. Calculate elapsed time from first metric timestamp
3. Map WorkoutMetric to FlSpot (x: elapsed seconds, y: total load)
4. Use cubic bezier curve (isCurved: true)
5. Show grid lines on both axes
6. Format x-axis labels as "Xs" (seconds)
7. Hide right and top axes
8. Fill below curve with 20% opacity purple

---

## Priority 3: Enhanced PR Celebration Animation

### Objective
Verify and enhance the existing `pr_celebration.dart` widget to match Kotlin implementation.

### Source Reference (Kotlin PRCelebrationAnimation.kt lines 45-208)

**Key Specifications:**
- 30 confetti particles
- Random colors: Gold, Orange, Pink, Purple, Blue, Green
- Physics: gravity (980 pixels/s²), random X velocity (-200 to +200), random Y velocity (-1200 to -400)
- Particle size: 4-12dp random
- Rotation speed: -5 to +5 degrees per frame
- Auto-dismiss after 3 seconds
- Pulsing "NEW PR!" text (1.0 to 1.15 scale)
- 3 spinning gold stars

### Flutter Implementation

**Verify File:** `lib/presentation/widgets/animations/pr_celebration.dart`

**Key Elements to Check:**

1. **ConfettiParticle data class:**
```dart
class ConfettiParticle {
  final double startX;      // 0.0-1.0 (fraction of width)
  final double startY;      // 0.0
  final Color color;
  final double size;        // 4-12 random
  final double rotationSpeed; // -5 to +5
  final double velocityX;   // -200 to +200
  final double velocityY;   // -1200 to -400
}
```

2. **Physics calculation in CustomPaint:**
```dart
final x = size.width * particle.startX + particle.velocityX * progress;
final y = particle.startY + particle.velocityY * progress +
          0.5 * 980 * progress * progress; // Gravity
final rotation = particle.rotationSpeed * progress * 360;
```

3. **Animations:**
- Confetti: 3 second linear progress 0→1
- Pulse: 500ms tween 1.0↔1.15 reverse repeat
- Stars: 2 second rotation 0→360

4. **Colors:**
```dart
final confettiColors = [
  Color(0xFFFFD700), // Gold
  Color(0xFFFFA500), // Orange
  Color(0xFFFF69B4), // Pink
  Color(0xFF9333EA), // Purple
  Color(0xFF3B82F6), // Blue
  Color(0xFF10B981), // Green
];
```

### Implementation Notes

1. Generate 30 particles with `List.generate(30, (i) => ...)`
2. Use `Random()` for all random values
3. Ensure gravity constant is 980 (pixels/s²)
4. Fade out particles as they fall: `alpha = 1.0 - progress * 0.5`
5. Only draw particles within canvas bounds
6. Use `CustomPaint` for confetti rendering
7. Auto-dismiss with `Future.delayed(Duration(seconds: 3))`

---

## Priority 4: Auto-Start/Auto-Stop Unified Card

### Objective
Create `auto_start_stop_card.dart` widget for countdown display in Just Lift mode.

### Source Reference (Kotlin JustLiftScreen.kt lines 537-597)

**Key Specifications:**
- Shows in Idle state (auto-start ready) and Active state (auto-stop countdown)
- Different colors based on state:
  - Auto-start countdown: primaryContainer
  - Auto-stop active: errorContainer
  - Active ready: surfaceVariant
  - Idle ready: tertiaryContainer
- 16dp rounded corners, 4dp elevation, 2dp border
- Large icon (32dp): PlayCircle (idle) or PanTool (active)
- Title text changes based on state

### Flutter Implementation

**File:** `lib/presentation/widgets/workout/auto_start_stop_card.dart`

**Widget Structure:**
```dart
class AutoStartStopCard extends StatelessWidget {
  final WorkoutState workoutState;
  final int? autoStartCountdown;
  final AutoStopUiState autoStopState;

  const AutoStartStopCard({
    required this.workoutState,
    this.autoStartCountdown,
    required this.autoStopState,
    super.key,
  });
}
```

**State Logic:**
```dart
final isIdle = workoutState == WorkoutState.idle;
final isActive = workoutState == WorkoutState.active;

// Only show card when idle or active
if (!isIdle && !isActive) return const SizedBox.shrink();

final containerColor = switch ((autoStartCountdown, autoStopState.isActive, isActive, isIdle)) {
  (int _, _, _, _) => colorScheme.primaryContainer,
  (_, true, _, _) => colorScheme.errorContainer,
  (_, _, true, _) => colorScheme.surfaceVariant,
  _ => colorScheme.tertiaryContainer,
};

final textColor = switch ((autoStartCountdown, autoStopState.isActive, isActive)) {
  (int _, _, _) => colorScheme.onPrimaryContainer,
  (_, true, _) => colorScheme.onErrorContainer,
  (_, _, true) => colorScheme.onSurfaceVariant,
  _ => colorScheme.onTertiaryContainer,
};

final icon = isIdle ? Icons.play_circle : Icons.pan_tool;

final titleText = switch ((autoStartCountdown, autoStopState.isActive, isActive, isIdle)) {
  (int _, _, _, _) => 'Starting...',
  (_, true, _, _) => 'Stopping in ${autoStopState.secondsRemaining}s...',
  (_, _, true, _) => 'Auto-Stop Ready',
  _ => 'Auto-Start Ready',
};
```

**Card Layout:**
```dart
Card(
  color: containerColor,
  shape: RoundedRectangleBorder(
    borderRadius: BorderRadius.circular(16),
    side: BorderSide(
      color: isIdle ? colorScheme.tertiary : colorScheme.outline,
      width: 2,
    ),
  ),
  elevation: 4,
  child: Padding(
    padding: const EdgeInsets.all(16),
    child: Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Icon(icon, size: 32, color: textColor),
        const SizedBox(width: 8),
        Text(
          titleText,
          style: textTheme.titleLarge?.copyWith(
            fontWeight: FontWeight.bold,
            color: textColor,
          ),
        ),
      ],
    ),
  ),
)
```

### Implementation Notes

1. Create `AutoStopUiState` class if needed:
```dart
class AutoStopUiState {
  final bool isActive;
  final int secondsRemaining;

  const AutoStopUiState({
    required this.isActive,
    required this.secondsRemaining,
  });
}
```

2. Widget should return `SizedBox.shrink()` if not in Idle or Active state
3. Use pattern matching for color/text logic
4. Icons: `Icons.play_circle` and `Icons.pan_tool`
5. Elevation and border should be visible

---

## General Implementation Guidelines

1. **Theme Integration:**
   - Use `Theme.of(context).colorScheme` for all colors
   - Use `Theme.of(context).textTheme` for typography
   - Ensure Material 3 compatibility

2. **Code Quality:**
   - Add documentation comments for all public classes/methods
   - Use `const` constructors where possible
   - Follow Flutter style guide
   - Run `flutter analyze` after each implementation

3. **File Organization:**
   - Widgets go in `lib/presentation/widgets/`
   - Use subdirectories: `workout/`, `animations/`, `dialogs/`
   - One widget per file (except small private helper widgets)

4. **Dependencies:**
   - `fl_chart: ^0.69.2` (already in pubspec.yaml)
   - Import Material and required domain models

5. **DO NOT:**
   - Integrate into screens yet (create standalone widgets first)
   - Create tests (separate task)
   - Modify existing working files unnecessarily

## Deliverables

For each priority task:
1. Create or update the specified file
2. Ensure widget is functional and follows specifications
3. Run `flutter analyze` to verify no errors
4. Report implementation notes and any decisions made

## Success Criteria

- All 4 widgets created/updated
- `flutter analyze` passes with 0 errors for new files
- Widgets visually match Kotlin implementations
- Proper Material 3 theming throughout
- Clear documentation comments
