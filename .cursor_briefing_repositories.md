# Repository Layer Porting Task - Kotlin → Dart

## Mission
Port the complete repository layer from Kotlin to Dart with 100% functionality preservation. Repositories bridge DAOs (already ported) with domain models (already ported) and provide clean interfaces for Riverpod providers in Phase 4.

## Source Files (Kotlin - VitruvianRedux)
```
C:\Users\dasbl\AndroidStudioProjects\VitruvianRedux\app\src\main\java\com\example\vitruvianredux\data\repository\
├── BleRepositoryImpl.kt        (564 lines - Interface + Implementation)
├── WorkoutRepository.kt        (478 lines - Implementation only)
├── ExerciseRepository.kt       (145 lines - Interface + Implementation)
└── PersonalRecordRepository.kt (107 lines - Implementation only)

Total: ~1,294 lines
```

## Target Structure (Dart - VPP_Flutter_Port)
```
lib/data/repositories/
├── ble_repository.dart              (BLE connection & protocol operations)
├── workout_repository.dart          (Workout sessions, metrics, routines, programs)
├── exercise_repository.dart         (Exercise library management)
└── personal_record_repository.dart  (PR tracking)
```

## Critical Requirements

### 1. Kotlin Flow → Dart Stream Transformation

**Kotlin Pattern:**
```kotlin
fun getAllSessions(): Flow<List<WorkoutSession>> {
    return workoutDao.getAllSessions().map { entities ->
        entities.map { it.toWorkoutSession() }
    }
}
```

**Dart Equivalent:**
```dart
Stream<List<WorkoutSession>> getAllSessions() {
  return workoutDao.watchAllSessions().map((entities) {
    return entities.map((entity) => entity.toWorkoutSession()).toList();
  });
}
```

**Key Points:**
- Kotlin `Flow<T>` → Dart `Stream<T>`
- Kotlin `StateFlow<T>` → Dart `Stream<T>` (or BehaviorSubject if using rxdart)
- DAO methods: use `.watch()` for streams, `.get()` for Future
- Always map entities to domain models in repositories

### 2. Result Type Pattern

**Kotlin Pattern:**
```kotlin
suspend fun saveSession(session: WorkoutSession): Result<Unit> {
    return try {
        val entity = session.toEntity()
        workoutDao.insertSession(entity)
        Result.success(Unit)
    } catch (e: Exception) {
        Timber.e(e, "Failed to save workout session")
        Result.failure(e)
    }
}
```

**Dart Equivalent (Option 1: Built-in Result type):**
```dart
Future<Result<void>> saveSession(WorkoutSession session) async {
  try {
    final entity = session.toEntity();
    await workoutDao.insertSession(entity);
    return Result.ok(null);
  } catch (e) {
    logger.e("Failed to save workout session: $e");
    return Result.err(e as Exception);
  }
}
```

**Dart Equivalent (Option 2: fpdart Result type - RECOMMENDED):**
```dart
import 'package:fpdart/fpdart.dart';

Future<Either<Exception, void>> saveSession(WorkoutSession session) async {
  try {
    final entity = session.toEntity();
    await workoutDao.insertSession(entity);
    return right(null);
  } catch (e) {
    logger.e("Failed to save workout session: $e");
    return left(e as Exception);
  }
}
```

**Use fpdart's Either<L, R>** for functional error handling (matches Kotlin Result best).

### 3. Entity ↔ Domain Model Mapping

**Kotlin Pattern (extension functions at file bottom):**
```kotlin
private fun WorkoutSessionEntity.toWorkoutSession() = WorkoutSession(
    id = id,
    timestamp = timestamp,
    mode = mode,
    reps = reps,
    // ... all fields
)

private fun WorkoutSession.toEntity() = WorkoutSessionEntity(
    id = id,
    timestamp = timestamp,
    mode = mode,
    reps = reps,
    // ... all fields
)
```

**Dart Equivalent (extension methods):**
```dart
// At bottom of file
extension WorkoutSessionEntityExt on WorkoutSessionEntity {
  WorkoutSession toWorkoutSession() {
    return WorkoutSession(
      id: id,
      timestamp: timestamp,
      mode: mode,
      reps: reps,
      // ... all fields
    );
  }
}

extension WorkoutSessionDomainExt on WorkoutSession {
  WorkoutSessionEntity toEntity() {
    return WorkoutSessionCompanion.insert(
      id: Value(id),
      timestamp: Value(BigInt.from(timestamp)),
      mode: Value(mode),
      reps: Value(reps),
      // ... all fields with Value() wrappers for Companion
    );
  }
}
```

**CRITICAL:** Drift entities need `Companion.insert()` or `Companion()` for insertions!

### 4. Dependency Injection (Hilt → None for now)

**Kotlin Pattern:**
```kotlin
@Singleton
class WorkoutRepository @Inject constructor(
    private val workoutDao: WorkoutDao,
    private val personalRecordDao: PersonalRecordDao
) {
    // ...
}
```

**Dart Pattern (constructor DI, no annotations):**
```dart
class WorkoutRepository {
  final WorkoutDao _workoutDao;
  final PrDao _prDao;

  WorkoutRepository(this._workoutDao, this._prDao);

  // Methods...
}
```

**Phase 4 Note:** We'll add Riverpod providers later. For now, just simple constructors.

### 5. Logging (Timber → dart logger)

**Kotlin:**
```kotlin
Timber.d("Saved workout session: ${session.id}")
Timber.e(e, "Failed to save workout session")
```

**Dart:**
```dart
import 'package:logger/logger.dart';

final logger = Logger();

logger.d("Saved workout session: ${session.id}");
logger.e("Failed to save workout session", error: e);
```

Add `logger: ^2.4.0` to pubspec.yaml if not present.

## Repository-Specific Guidance

### BleRepository (Most Complex - 564 lines)

**Key Kotlin Features:**
- Interface `BleRepository` + implementation `BleRepositoryImpl`
- Multiple `StateFlow` and `SharedFlow` for BLE streams
- Android BluetoothAdapter integration
- ScanCallback for device discovery
- VitruvianBleManager wrapper
- ProtocolBuilder for command construction
- ConnectionLogger integration

**Dart Equivalent Patterns:**

1. **StateFlow → StreamController + BehaviorSubject:**
```kotlin
private val _connectionState = MutableStateFlow<ConnectionState>(ConnectionState.Disconnected)
override val connectionState: StateFlow<ConnectionState> = _connectionState.asStateFlow()
```

**Dart:**
```dart
import 'package:rxdart/rxdart.dart';

final _connectionState = BehaviorSubject<ConnectionState>.seeded(const Disconnected());
Stream<ConnectionState> get connectionState => _connectionState.stream;
```

2. **SharedFlow → StreamController:**
```kotlin
private val _monitorData = MutableSharedFlow<WorkoutMetric>(replay = 0)
override val monitorData: Flow<WorkoutMetric> = _monitorData.asSharedFlow()
```

**Dart:**
```dart
final _monitorData = StreamController<WorkoutMetric>.broadcast();
Stream<WorkoutMetric> get monitorData => _monitorData.stream;
```

3. **BLE Scanning (Android BluetoothAdapter → flutter_blue_plus):**
```kotlin
val scanner = bluetoothAdapter.bluetoothLeScanner
scanner.startScan(null, scanSettings, scanCallback)
```

**Dart:**
```dart
import 'package:flutter_blue_plus/flutter_blue_plus.dart';

// Start scan
final subscription = FlutterBluePlus.scanResults.listen((results) {
  for (ScanResult result in results) {
    if (result.device.platformName.startsWith(BleConstants.deviceNamePrefix)) {
      _scannedDevices.add(result);
    }
  }
});

await FlutterBluePlus.startScan(
  timeout: Duration(milliseconds: BleConstants.scanTimeoutMs),
);
```

4. **VitruvianBleManager Integration:**
```kotlin
bleManager = VitruvianBleManager(context, connectionLogger).apply {
    setDeviceInfo(device.name, device.address)
    // Collect flows...
}
```

**Dart:**
```dart
_bleManager = VitruvianBleManager(connectionLogger);
await _bleManager.setDeviceInfo(deviceName, deviceAddress);

// Forward BLE manager streams to repository streams
_bleManager.monitorData.listen((metric) {
  _monitorData.add(metric);
});
```

### WorkoutRepository (478 lines)

**Key Features:**
- No interface (just implementation)
- Workout sessions CRUD
- Batch metrics insert
- Routine management with exercises
- Weekly programs with embedded relations
- Personal records integration
- Complex entity↔domain mapping with enums

**Critical Mapping Examples:**

1. **Enum Serialization:**
```kotlin
mode = when (workoutType) {
    is WorkoutType.Program -> when (workoutType.mode) {
        is ProgramMode.OldSchool -> "OldSchool"
        is ProgramMode.Pump -> "Pump"
        // ...
    }
    is WorkoutType.Echo -> "Echo"
}
```

**Dart (use freezed when() for type safety):**
```dart
final modeString = workoutType.when(
  program: (mode) => mode.when(
    oldSchool: () => 'OldSchool',
    pump: () => 'Pump',
    // ...
  ),
  echo: (level, eccentricLoad) => 'Echo',
);
```

2. **List Serialization:**
```kotlin
setReps = setReps.joinToString(",") // List<Int> → String
// Deserialize:
setReps = if (setReps.isEmpty()) emptyList() else setReps.split(",").mapNotNull { it.toIntOrNull() }
```

**Dart:**
```dart
final setRepsString = setReps.join(','); // List<int> → String
// Deserialize:
final setReps = setRepsString.isEmpty
  ? <int>[]
  : setRepsString.split(',').map(int.tryParse).whereType<int>().toList();
```

### ExerciseRepository (145 lines)

**Key Features:**
- Interface + implementation
- Exercise library queries
- Search and filtering
- Favorite toggling
- ExerciseImporter integration (SKIP - create stub/TODO)

**Dart Pattern:**
```dart
abstract class ExerciseRepository {
  Stream<List<Exercise>> getAllExercises();
  Stream<List<Exercise>> searchExercises(String query);
  Stream<List<Exercise>> filterByMuscleGroup(String muscleGroup);
  // ...
}

class ExerciseRepositoryImpl implements ExerciseRepository {
  final ExerciseDao _exerciseDao;

  ExerciseRepositoryImpl(this._exerciseDao);

  @override
  Stream<List<Exercise>> getAllExercises() {
    return _exerciseDao.watchAllExercises().map((entities) {
      return entities.map((e) => e.toExercise()).toList();
    });
  }
  // ...
}
```

**ExerciseImporter Stub (for now):**
```dart
class ExerciseImporter {
  // TODO: Implement in Phase 3.5 - Import exercises from JSON assets
  Future<Either<Exception, void>> importExercises() async {
    throw UnimplementedError('ExerciseImporter not yet implemented');
  }
}
```

### PersonalRecordRepository (107 lines)

**Key Features:**
- Simple repository (no interface)
- PR queries
- PR update logic
- Entity mapping

**Straightforward port** - follow WorkoutRepository patterns.

## Deliverables

Create these 4 files in `lib/data/repositories/`:

1. **ble_repository.dart** (~600 lines estimated)
   - Abstract class `BleRepository`
   - Class `BleRepositoryImpl implements BleRepository`
   - All streams using StreamController/BehaviorSubject
   - flutter_blue_plus integration
   - VitruvianBleManager integration
   - Protocol command sending
   - ConnectionLogger integration

2. **workout_repository.dart** (~500 lines estimated)
   - Class `WorkoutRepository` (no interface)
   - Session CRUD
   - Metrics batch operations
   - Routine management
   - Weekly program management
   - Entity mapping extensions at bottom

3. **exercise_repository.dart** (~150 lines estimated)
   - Abstract class `ExerciseRepository`
   - Class `ExerciseRepositoryImpl implements ExerciseRepository`
   - Exercise queries
   - ExerciseImporter stub

4. **personal_record_repository.dart** (~120 lines estimated)
   - Class `PersonalRecordRepository`
   - PR queries
   - PR update logic
   - Entity mapping extensions

## Validation Checklist

- [ ] All 4 repository files created
- [ ] All Kotlin Flow methods → Dart Stream methods
- [ ] All Result<T> methods use Either<Exception, T>
- [ ] All entity↔domain mapping extensions implemented
- [ ] BLE repository integrates with flutter_blue_plus
- [ ] BLE repository integrates with VitruvianBleManager
- [ ] Workout repository integrates with WorkoutDao + PrDao
- [ ] Exercise repository integrates with ExerciseDao
- [ ] PR repository integrates with PrDao
- [ ] `flutter pub get` succeeds
- [ ] `flutter analyze` has no repository errors
- [ ] Imports all resolve (DAOs, domain models, packages)

## Dependencies

Add to `pubspec.yaml` if missing:
```yaml
dependencies:
  fpdart: ^1.1.0          # Functional error handling (Either)
  logger: ^2.4.0          # Logging
  rxdart: ^0.28.0         # BehaviorSubject for StateFlow equivalent

  # Already added:
  # flutter_blue_plus: ^1.32.12
  # drift: ^2.20.3
```

## Import Structure

Each repository file should have:
```dart
// Flutter/Dart
import 'dart:async';

// Packages
import 'package:fpdart/fpdart.dart';
import 'package:logger/logger.dart';
import 'package:rxdart/rxdart.dart';
import 'package:flutter_blue_plus/flutter_blue_plus.dart'; // BLE repository only

// Project - DAOs
import '../database/app_database.dart';
import '../database/daos/workout_dao.dart';
import '../database/daos/pr_dao.dart';
// etc.

// Project - Domain models
import '../../domain/models/connection_state.dart';
import '../../domain/models/workout_session.dart';
// etc.

// Project - BLE (BLE repository only)
import '../ble/vitruvian_ble_manager.dart';
import '../ble/protocol_builder.dart';
import '../ble/constants.dart';
```

## Notes

- **DO NOT** modify domain models or DAOs - they're already ported
- **DO** create entity mapping extensions at bottom of each file
- **DO** use Either<Exception, T> for Result types (fpdart)
- **DO** use StreamController/BehaviorSubject for Flow equivalents
- **DO** preserve all method names and signatures from Kotlin
- **DO** add logger statements matching Kotlin Timber calls
- **SKIP** ExerciseImporter implementation (create stub with TODO)
- Phase 4 will add Riverpod providers - just focus on clean repository interfaces now

## References

- Drift Documentation: https://drift.simonbinder.eu/docs/
- flutter_blue_plus: https://pub.dev/packages/flutter_blue_plus
- fpdart: https://pub.dev/packages/fpdart
- rxdart: https://pub.dev/packages/rxdart

**PRIORITY: Correctness > Speed. All repository methods must be functional before moving on.**
