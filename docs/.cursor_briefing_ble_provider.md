# BLE Connection Provider Implementation Briefing

## Mission
Port BLE connection state management from MainViewModel.kt (lines 542-689) to a focused Riverpod provider. This provider manages Bluetooth Low Energy device discovery, connection, and monitoring.

## Source Reference
**Kotlin File:** `C:\Users\dasbl\AndroidStudioProjects\VitruvianRedux\app\src\main\java\com\example\vitruvianredux\presentation\viewmodel\MainViewModel.kt`
**Lines:** 542-689 (BLE connection methods), 55-239 (BLE state properties)

## Target File
**Path:** `lib/presentation/providers/ble_connection_provider.dart`
**Estimated Size:** ~300 lines

## State to Manage

Based on MainViewModel.kt analysis, manage these 5 state properties:

### 1. Connection State (from repository)
```kotlin
// Line 55 - MainViewModel.kt
val connectionState: StateFlow<ConnectionState> = bleRepository.connectionState
```
**Dart equivalent:**
```dart
// Stream directly from BleRepository
final connectionStateProvider = StreamProvider<ConnectionState>((ref) {
  final bleRepo = ref.watch(bleRepositoryProvider);
  return bleRepo.connectionState;
});
```

### 2. Scanned Devices
```kotlin
// Lines 88-89
private val _scannedDevices = MutableStateFlow<List<ScannedDevice>>(emptyList())
val scannedDevices: StateFlow<List<ScannedDevice>> = _scannedDevices.asStateFlow()
```
**Dart equivalent:**
```dart
class BleConnectionNotifier extends StateNotifier<BleConnectionState> {
  List<ScannedDevice> get scannedDevices => state.scannedDevices;

  void _updateScannedDevices(List<ScannedDevice> devices) {
    state = state.copyWith(scannedDevices: devices);
  }
}
```

### 3. Auto-Connecting Flag
```kotlin
// Lines 236-237
private val _isAutoConnecting = MutableStateFlow(false)
val isAutoConnecting: StateFlow<Boolean> = _isAutoConnecting.asStateFlow()
```

### 4. Connection Error
```kotlin
// Lines 239-240
private val _connectionError = MutableStateFlow<String?>(null)
val connectionError: StateFlow<String?> = _connectionError.asStateFlow()
```

### 5. Connection Lost During Workout
```kotlin
// Lines 253-254
private val _connectionLostDuringWorkout = MutableStateFlow(false)
val connectionLostDuringWorkout: StateFlow<Boolean> = _connectionLostDuringWorkout.asStateFlow()
```

## BLE Connection State Model

Create a freezed state class to hold all BLE connection state:

```dart
import 'package:freezed_annotation/freezed_annotation.dart';
import '../../domain/models/connection_state.dart';
import '../../domain/models/scanned_device.dart';

part 'ble_connection_state.freezed.dart';

@freezed
class BleConnectionState with _$BleConnectionState {
  const factory BleConnectionState({
    @Default([]) List<ScannedDevice> scannedDevices,
    @Default(false) bool isAutoConnecting,
    String? connectionError,
    @Default(false) bool connectionLostDuringWorkout,
  }) = _BleConnectionState;
}
```

## Key Methods to Implement

### 1. Start Scanning (Lines 542-555)
```kotlin
fun startScanning() {
    viewModelScope.launch {
        _scannedDevices.value = emptyList()
        val result = bleRepository.startScanning()
        if (result.isSuccess) {
            Timber.d("BLE scan started successfully")
            // Collect scanned devices
            bleRepository.scannedDevices.collect { devices ->
                _scannedDevices.value = devices
            }
        } else {
            Timber.e("Failed to start BLE scan: ${result.exceptionOrNull()?.message}")
        }
    }
}
```

**Dart pattern:**
```dart
Future<void> startScanning() async {
  state = state.copyWith(scannedDevices: []);

  final result = await _bleRepository.startScanning();
  result.fold(
    (error) => logger.e('Failed to start BLE scan: $error'),
    (_) {
      logger.d('BLE scan started successfully');
      // Subscribe to scanned devices stream
      _scanSubscription = _bleRepository.scannedDevices.listen((devices) {
        state = state.copyWith(scannedDevices: devices);
      });
    },
  );
}
```

### 2. Stop Scanning (Lines 556-561)
```kotlin
fun stopScanning() {
    viewModelScope.launch {
        bleRepository.stopScanning()
        Timber.d("BLE scan stopped")
    }
}
```

**Dart:**
```dart
Future<void> stopScanning() async {
  await _bleRepository.stopScanning();
  await _scanSubscription?.cancel();
  _scanSubscription = null;
  logger.d('BLE scan stopped');
}
```

### 3. Connect to Device (Lines 562-585)
```kotlin
fun connectToDevice(deviceAddress: String) {
    viewModelScope.launch {
        stopScanning()
        _connectionError.value = null

        val result = bleRepository.connect(deviceAddress)
        if (result.isFailure) {
            val error = result.exceptionOrNull()?.message ?: "Unknown error"
            _connectionError.value = error
            Timber.e("Connection failed: $error")
        }
    }
}
```

**Dart:**
```dart
Future<void> connectToDevice(String deviceAddress) async {
  await stopScanning();
  state = state.copyWith(connectionError: null);

  final result = await _bleRepository.connect(deviceAddress);
  result.fold(
    (error) {
      final errorMsg = error.toString();
      state = state.copyWith(connectionError: errorMsg);
      logger.e('Connection failed: $errorMsg');
    },
    (_) => logger.d('Connection initiated for $deviceAddress'),
  );
}
```

### 4. Ensure Connection with Auto-Connect (Lines 586-675)
```kotlin
fun ensureConnection(
    onConnected: () -> Unit,
    onFailed: () -> Unit
) {
    viewModelScope.launch {
        if (connectionState.value is ConnectionState.Connected) {
            onConnected()
            return@launch
        }

        _isAutoConnecting.value = true
        _connectionError.value = null

        // Start scanning
        startScanning()

        // Wait for device with timeout
        val found = withTimeoutOrNull(30000) {
            scannedDevices
                .filter { it.isNotEmpty() }
                .take(1)
                .collect { devices ->
                    // Auto-connect to first Vitruvian device
                    val vitruvianDevice = devices.firstOrNull()
                    if (vitruvianDevice != null) {
                        connectToDevice(vitruvianDevice.address)

                        // Wait for connection
                        connectionState
                            .filter { it is ConnectionState.Connected }
                            .take(1)
                            .collect {
                                _isAutoConnecting.value = false
                                onConnected()
                            }
                    }
                }
        }

        if (found == null) {
            _isAutoConnecting.value = false
            _connectionError.value = "Auto-connect timeout: No devices found"
            onFailed()
        }
    }
}
```

**Dart pattern:** (Use async/await with Future.delayed for timeout)
```dart
Future<void> ensureConnection({
  required VoidCallback onConnected,
  required VoidCallback onFailed,
}) async {
  // Check if already connected
  final currentState = await ref.read(connectionStateProvider.future);
  if (currentState is Connected) {
    onConnected();
    return;
  }

  state = state.copyWith(
    isAutoConnecting: true,
    connectionError: null,
  );

  // Start scanning
  await startScanning();

  // Wait for device with 30s timeout
  try {
    await Future.any([
      _waitForDeviceAndConnect(onConnected),
      Future.delayed(Duration(seconds: 30)).then((_) => throw TimeoutException()),
    ]);
  } on TimeoutException {
    state = state.copyWith(
      isAutoConnecting: false,
      connectionError: 'Auto-connect timeout: No devices found',
    );
    onFailed();
  } catch (e) {
    state = state.copyWith(
      isAutoConnecting: false,
      connectionError: e.toString(),
    );
    onFailed();
  }
}

Future<void> _waitForDeviceAndConnect(VoidCallback onConnected) async {
  // Wait for first scanned device
  await for (final devices in _scanSubscription?.stream ?? Stream.empty()) {
    if (devices.isNotEmpty) {
      final device = devices.first;
      await connectToDevice(device.address);

      // Wait for connection
      await for (final connState in ref.read(connectionStateProvider.stream)) {
        if (connState is Connected) {
          state = state.copyWith(isAutoConnecting: false);
          onConnected();
          return;
        }
      }
    }
  }
}
```

### 5. Cancel Auto-Connecting (Lines 676-682)
```kotlin
fun cancelAutoConnecting() {
    _isAutoConnecting.value = false
    stopScanning()
    disconnect()
    Timber.d("Auto-connect cancelled")
}
```

### 6. Dismiss Connection Lost Alert (Lines 683-688)
```kotlin
fun dismissConnectionLostAlert() {
    _connectionLostDuringWorkout.value = false
}
```

### 7. Disconnect (Line 689)
```kotlin
fun disconnect() {
    viewModelScope.launch {
        bleRepository.disconnect()
    }
}
```

## Provider Structure

```dart
import 'dart:async';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:logger/logger.dart';
import '../../data/repositories/ble_repository.dart';
import '../../domain/models/connection_state.dart';
import '../../domain/models/scanned_device.dart';
import 'ble_connection_state.dart';

final logger = Logger();

/// Provider for BLE repository instance
final bleRepositoryProvider = Provider<BleRepository>((ref) {
  throw UnimplementedError('bleRepositoryProvider must be overridden');
});

/// Stream provider for connection state from repository
final connectionStateProvider = StreamProvider<ConnectionState>((ref) {
  final bleRepo = ref.watch(bleRepositoryProvider);
  return bleRepo.connectionState;
});

/// StateNotifier for BLE connection management
class BleConnectionNotifier extends StateNotifier<BleConnectionState> {
  final BleRepository _bleRepository;
  final Ref _ref;

  StreamSubscription<List<ScannedDevice>>? _scanSubscription;

  BleConnectionNotifier(this._bleRepository, this._ref)
      : super(const BleConnectionState());

  // Methods: startScanning, stopScanning, connectToDevice, ensureConnection, etc.

  @override
  void dispose() {
    _scanSubscription?.cancel();
    super.dispose();
  }
}

/// Provider for BLE connection notifier
final bleConnectionProvider = StateNotifierProvider<BleConnectionNotifier, BleConnectionState>((ref) {
  final bleRepo = ref.watch(bleRepositoryProvider);
  return BleConnectionNotifier(bleRepo, ref);
});

/// Actions provider for BLE operations
final bleConnectionActionsProvider = Provider<BleConnectionActions>((ref) {
  final notifier = ref.watch(bleConnectionProvider.notifier);
  return BleConnectionActions(notifier);
});

class BleConnectionActions {
  final BleConnectionNotifier _notifier;

  BleConnectionActions(this._notifier);

  Future<void> startScanning() => _notifier.startScanning();
  Future<void> stopScanning() => _notifier.stopScanning();
  Future<void> connectToDevice(String address) => _notifier.connectToDevice(address);
  Future<void> ensureConnection({
    required VoidCallback onConnected,
    required VoidCallback onFailed,
  }) => _notifier.ensureConnection(
    onConnected: onConnected,
    onFailed: onFailed,
  );
  Future<void> cancelAutoConnecting() => _notifier.cancelAutoConnecting();
  void dismissConnectionLostAlert() => _notifier.dismissConnectionLostAlert();
  Future<void> disconnect() => _notifier.disconnect();
}
```

## Dependencies

**Already available:**
- BleRepository (from Phase 3) - `lib/data/repositories/ble_repository.dart`
- ConnectionState domain model - `lib/domain/models/connection_state.dart`
- ScannedDevice domain model - needs to be created if not exists

**Packages:**
- flutter_riverpod: ^2.6.1 (already in pubspec.yaml)
- logger: ^2.4.0 (already in pubspec.yaml)
- freezed_annotation: ^2.5.7 (for state class)

## ScannedDevice Model (Create if missing)

```dart
// lib/domain/models/scanned_device.dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'scanned_device.freezed.dart';

@freezed
class ScannedDevice with _$ScannedDevice {
  const factory ScannedDevice({
    required String name,
    required String address,
    required int rssi,
  }) = _ScannedDevice;
}
```

## Validation Checklist

- [ ] BleConnectionState freezed class created
- [ ] ScannedDevice model exists (create if missing)
- [ ] BleConnectionNotifier implements all 7 methods
- [ ] Stream subscriptions properly managed (cancel in dispose)
- [ ] Timeout handling for ensureConnection (30s)
- [ ] Error handling with Either<Exception, T> from repository
- [ ] Logger statements match Kotlin Timber usage
- [ ] Provider dependencies correct (BleRepository)
- [ ] Actions class exposes all methods
- [ ] `flutter pub run build_runner build` for freezed generation
- [ ] `flutter analyze lib/presentation/providers/` passes
- [ ] No blocking errors

## Notes

1. **Stream Management:** Cancel scan subscription in `dispose()` to prevent leaks
2. **Timeout Pattern:** Use `Future.any()` with `Future.delayed()` for 30s timeout
3. **Callback Pattern:** Dart uses `VoidCallback` typedef instead of `() -> Unit`
4. **Async/Await:** All repository calls are async, use `await` with proper error handling
5. **Either Pattern:** BleRepository returns `Either<Exception, T>`, use `.fold()` for handling

## Reference MainViewModel.kt Line Numbers

- Connection state stream: line 55
- Scanned devices state: lines 88-89
- Auto-connecting flag: lines 236-237
- Connection error: lines 239-240
- Connection lost flag: lines 253-254
- startScanning(): lines 542-555
- stopScanning(): lines 556-561
- connectToDevice(): lines 562-585
- ensureConnection(): lines 586-675
- cancelAutoConnecting(): lines 676-682
- dismissConnectionLostAlert(): lines 683-688
- disconnect(): line 689

## Success Criteria

1. All 7 BLE connection methods ported and functional
2. State management follows Riverpod StateNotifier pattern
3. Freezed code generation successful
4. Zero compilation errors
5. Matches Kotlin behavior: scanning, auto-connect, timeout handling
6. Proper stream subscription lifecycle management
