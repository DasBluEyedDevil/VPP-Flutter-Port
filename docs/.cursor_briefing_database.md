# Database Layer Porting Task - Room → Drift

## Mission
Port the complete Room database layer from Kotlin to Drift (Flutter) with 100% schema fidelity and preserved query patterns.

## Source Files (Kotlin - VitruvianRedux)
```
C:\Users\dasbl\AndroidStudioProjects\VitruvianRedux\app\src\main\java\com\example\vitruvianredux\data\local\
├── WorkoutDatabase.kt          (Database definition, version 15)
├── WorkoutEntities.kt          (6 entities + embedded relations)
├── ExerciseEntity.kt           (2 entities: Exercise + ExerciseVideo)
├── PersonalRecordEntity.kt     (1 entity)
├── ConnectionLogEntity.kt      (1 entity)
├── WorkoutDao.kt               (Workout + Metrics queries)
├── ExerciseDao.kt              (Exercise library queries)
├── PersonalRecordDao.kt        (PR tracking queries)
├── ConnectionLogDao.kt         (Debug log queries)
└── Converters.kt               (Type converters - if exists, check directory)
```

## Target Structure (Drift - VPP_Flutter_Port)
```
lib/data/database/
├── app_database.dart                    (Main @DriftDatabase with 10 tables)
├── tables/
│   ├── workout_sessions.dart            (WorkoutSessionEntity)
│   ├── workout_metrics.dart             (WorkoutMetricEntity - HIGH PERFORMANCE!)
│   ├── routines.dart                    (RoutineEntity)
│   ├── routine_exercises.dart           (RoutineExerciseEntity)
│   ├── exercises.dart                   (ExerciseEntity)
│   ├── exercise_videos.dart             (ExerciseVideoEntity)
│   ├── personal_records.dart            (PersonalRecordEntity)
│   ├── weekly_programs.dart             (WeeklyProgramEntity)
│   ├── program_days.dart                (ProgramDayEntity)
│   └── connection_logs.dart             (ConnectionLogEntity)
├── daos/
│   ├── workout_dao.dart                 (Workout + Metrics operations)
│   ├── exercise_dao.dart                (Exercise library operations)
│   ├── pr_dao.dart                      (PR tracking operations)
│   └── connection_log_dao.dart          (Connection logging)
└── converters.dart                      (Type converters for Drift)
```

## Critical Requirements

### 1. Database Definition (`app_database.dart`)
```dart
import 'package:drift/drift.dart';
import 'dart:io';
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;

part 'app_database.g.dart';

@DriftDatabase(
  tables: [
    WorkoutSessions,
    WorkoutMetrics,
    Routines,
    RoutineExercises,
    Exercises,
    ExerciseVideos,
    PersonalRecords,
    WeeklyPrograms,
    ProgramDays,
    ConnectionLogs,
  ],
  daos: [
    WorkoutDao,
    ExerciseDao,
    PrDao,
    ConnectionLogDao,
  ],
)
class AppDatabase extends _$AppDatabase {
  AppDatabase() : super(_openConnection());

  @override
  int get schemaVersion => 15;  // Match Kotlin database version

  static LazyDatabase _openConnection() {
    return LazyDatabase(() async {
      final dbFolder = await getApplicationDocumentsDirectory();
      final file = File(p.join(dbFolder.path, 'vitruvian_workout.db'));
      return NativeDatabase(file);
    });
  }
}
```

### 2. Performance-Critical Table (`workout_metrics.dart`)
```dart
// THIS TABLE RECEIVES 100Hz INSERTS (6000 records/minute during workouts)
// Must use efficient batch inserts in DAO
class WorkoutMetrics extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get sessionId => text()();
  Int64Column get timestamp => int64()();
  RealColumn get loadA => real()();
  RealColumn get loadB => real()();
  IntColumn get positionA => integer()();
  IntColumn get positionB => integer()();
  IntColumn get ticks => integer()();
}

// DAO must implement:
// - insertMetricsBatch(List<WorkoutMetricsCompanion> metrics) for 100Hz performance
// - Transactions for bulk inserts
```

### 3. Foreign Key Relationships (CRITICAL - Must Preserve!)
```
RoutineExercises → Routines (CASCADE delete)
ProgramDays → WeeklyPrograms (CASCADE delete)
ProgramDays → Routines (CASCADE delete)
ExerciseVideos → Exercises (CASCADE delete)
```

Example in Drift:
```dart
class RoutineExercises extends Table {
  // ...
  TextColumn get routineId => text().references(Routines, #id, onDelete: KeyAction.cascade)();
}
```

### 4. Unique Constraints
```dart
// PersonalRecords: unique constraint on (exerciseId, workoutMode)
@override
List<Set<Column>> get uniqueKeys => [
  {exerciseId, workoutMode},
];
```

### 5. Indexes
```dart
// RoutineExercises: index on routineId
@override
List<Index> get indexes => [
  Index('idx_routine_exercises_routine_id', [routineId]),
];

// ConnectionLogs: index on timestamp for queries
@override
List<Index> get indexes => [
  Index('idx_connection_logs_timestamp', [timestamp]),
];
```

### 6. Type Converters (if needed)
Check if Kotlin Converters.kt exists. Common needs:
- List<String> → comma-separated strings
- WorkoutMode enum → String
- JSON serialization for complex types

Example:
```dart
class StringListConverter extends TypeConverter<List<String>, String> {
  const StringListConverter();

  @override
  List<String> fromSql(String fromDb) {
    return fromDb.isEmpty ? [] : fromDb.split(',');
  }

  @override
  String toSql(List<String> value) {
    return value.join(',');
  }
}
```

### 7. Embedded Relations Pattern
Kotlin `WeeklyProgramWithDays` uses `@Embedded` + `@Relation`:
```kotlin
data class WeeklyProgramWithDays(
    @Embedded val program: WeeklyProgramEntity,
    @Relation(parentColumn = "id", entityColumn = "programId")
    val days: List<ProgramDayEntity>
)
```

Drift equivalent:
```dart
// In WorkoutDao or a dedicated query method:
Future<List<WeeklyProgramWithDays>> getWeeklyProgramsWithDays() {
  return (select(weeklyPrograms)
    ..orderBy([(t) => OrderingTerm.desc(t.lastUsed)]))
    .join([
      leftOuterJoin(programDays, programDays.programId.equalsExp(weeklyPrograms.id)),
    ])
    .map((row) {
      final program = row.readTable(weeklyPrograms);
      final day = row.readTableOrNull(programDays);
      return /* construct result */;
    })
    .get();
}
```

### 8. DAO Query Patterns
Study Kotlin DAOs and replicate:
- CRUD operations (insert, update, delete)
- Queries with filters, sorting, pagination
- Reactive streams (`watch()` instead of `Flow`)
- Batch operations
- Transactions

Example:
```dart
@DriftAccessor(tables: [WorkoutSessions, WorkoutMetrics])
class WorkoutDao extends DatabaseAccessor<AppDatabase> with _$WorkoutDaoMixin {
  final AppDatabase db;
  WorkoutDao(this.db) : super(db);

  // INSERT with RETURNING id
  Future<int> insertSession(WorkoutSessionsCompanion session) {
    return into(workoutSessions).insert(session);
  }

  // BATCH INSERT for 100Hz metrics (CRITICAL PERFORMANCE)
  Future<void> insertMetricsBatch(List<WorkoutMetricsCompanion> metrics) {
    return batch((batch) {
      batch.insertAll(workoutMetrics, metrics);
    });
  }

  // WATCH queries (reactive streams)
  Stream<List<WorkoutSession>> watchRecentSessions({int limit = 20}) {
    return (select(workoutSessions)
      ..orderBy([(t) => OrderingTerm.desc(t.timestamp)])
      ..limit(limit))
    .watch();
  }
}
```

## Deliverables
1. **app_database.dart** - Complete database definition with all 10 tables and 4 DAOs
2. **10 table files** in `tables/` directory - One per entity
3. **4 DAO files** in `daos/` directory - WorkoutDao, ExerciseDao, PrDao, ConnectionLogDao
4. **converters.dart** (if type converters needed)
5. **All foreign key constraints preserved**
6. **All indexes preserved**
7. **All unique constraints preserved**
8. **Batch insert optimization for WorkoutMetrics** (100Hz requirement)

## Validation Checklist
- [ ] `flutter pub run build_runner build` completes successfully
- [ ] All 10 tables defined with correct column types
- [ ] All foreign keys match Kotlin schema (CASCADE deletes preserved)
- [ ] All indexes created
- [ ] All unique constraints defined
- [ ] All DAO methods implemented
- [ ] Batch insert for metrics uses `batch()` API
- [ ] Reactive streams use `watch()` not `get()`
- [ ] `flutter analyze` passes with zero errors

## Notes
- **DO NOT** modify domain models - they're already ported in Phase 2
- **DO** import domain models where needed (e.g., WorkoutType for type converters)
- Use `DateTime.now().millisecondsSinceEpoch` for timestamp defaults
- Column names should be snake_case (Drift convention)
- Table class names should be PascalCase plural (e.g., `WorkoutSessions`)
- DAO method names should be camelCase

## References
- Drift Documentation: https://drift.simonbinder.eu/docs/
- Room → Drift Migration: https://drift.simonbinder.eu/docs/getting-started/from_room/
- Domain models are in: `lib/domain/models/`

**PRIORITY: Correctness > Speed. Schema must match 100% before moving on.**
