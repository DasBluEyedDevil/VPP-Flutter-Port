# Analytics Providers Implementation - Condensed Briefing

## Mission
Implement 4 analytics providers that wrap repository data for UI consumption. These are simpler StreamProvider wrappers around repository Streams.

## Target Files
1. `lib/presentation/providers/workout_history_provider.dart`
2. `lib/presentation/providers/personal_record_provider.dart`
3. `lib/presentation/providers/routine_provider.dart`
4. `lib/presentation/providers/weekly_program_provider.dart`

## Source Reference
**Kotlin File:** MainViewModel.kt
- Workout history: lines 98-110
- Personal records: lines 112-116
- Routines: lines 127-135
- Weekly program: lines 137-145

## Pattern for All 4 Providers

Each provider follows this simple pattern:

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../data/repositories/[repository_name].dart';
import '../../domain/models/[model_name].dart';

/// Provider for [repository] instance
final [repository]Provider = Provider<[Repository]>((ref) {
  throw UnimplementedError('[repository]Provider must be overridden');
});

/// Stream provider for [data]
///
/// Ported from MainViewModel.kt [stateFlowName] (lines X-Y)
final [data]Provider = StreamProvider<List<[Model]>>((ref) {
  final repo = ref.watch([repository]Provider);
  return repo.[streamName];
});

/// Actions provider for [operations]
final [data]ActionsProvider = Provider<[Actions]>((ref) {
  final repo = ref.watch([repository]Provider);
  return [Actions](repo);
});

class [Actions] {
  final [Repository] _repo;

  [Actions](this._repo);

  // Action methods that call repository
  Future<void> someAction() => _repo.someMethod();
}
```

## 1. Workout History Provider

**Kotlin Reference:**
```kotlin
// Lines 98-110
private val _workoutHistory = MutableStateFlow<List<WorkoutSession>>(emptyList())
val workoutHistory: StateFlow<List<WorkoutSession>> = _workoutHistory.asStateFlow()

init {
    viewModelScope.launch {
        workoutRepository.getAllWorkoutSessions()
            .collect { sessions ->
                _workoutHistory.value = sessions
            }
    }
}
```

**Dart Implementation:**
```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../data/repositories/workout_repository.dart';
import '../../domain/models/workout_session.dart';

final workoutRepositoryProvider = Provider<WorkoutRepository>((ref) {
  throw UnimplementedError('workoutRepositoryProvider must be overridden');
});

/// Stream provider for workout history
///
/// Ported from MainViewModel.kt workoutHistory (lines 98-110)
final workoutHistoryProvider = StreamProvider<List<WorkoutSession>>((ref) {
  final repo = ref.watch(workoutRepositoryProvider);
  return repo.getAllWorkoutSessions();
});

/// Actions provider for workout history operations
final workoutHistoryActionsProvider = Provider<WorkoutHistoryActions>((ref) {
  final repo = ref.watch(workoutRepositoryProvider);
  return WorkoutHistoryActions(repo);
});

class WorkoutHistoryActions {
  final WorkoutRepository _repo;

  WorkoutHistoryActions(this._repo);

  Future<void> deleteWorkoutSession(String sessionId) async {
    await _repo.deleteWorkoutSession(sessionId);
  }

  Future<List<WorkoutSession>> getSessionsByDateRange(DateTime start, DateTime end) {
    return _repo.getWorkoutSessionsByDateRange(start, end);
  }
}
```

## 2. Personal Record Provider

**Kotlin Reference:**
```kotlin
// Lines 112-116
val personalRecords: StateFlow<List<PersonalRecord>> =
    workoutRepository.getAllPersonalRecords()
        .stateIn(viewModelScope, SharingStarted.Lazily, emptyList())
```

**Dart Implementation:**
```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../data/repositories/workout_repository.dart';
import '../../domain/models/personal_record.dart';

/// Stream provider for personal records
///
/// Ported from MainViewModel.kt personalRecords (lines 112-116)
final personalRecordsProvider = StreamProvider<List<PersonalRecord>>((ref) {
  final repo = ref.watch(workoutRepositoryProvider);
  return repo.getAllPersonalRecords();
});

/// Actions provider for personal record operations
final personalRecordActionsProvider = Provider<PersonalRecordActions>((ref) {
  final repo = ref.watch(workoutRepositoryProvider);
  return PersonalRecordActions(repo);
});

class PersonalRecordActions {
  final WorkoutRepository _repo;

  PersonalRecordActions(this._repo);

  Future<PersonalRecord?> getPRForExercise(int exerciseId) {
    return _repo.getPersonalRecordForExercise(exerciseId);
  }
}
```

## 3. Routine Provider

**Kotlin Reference:**
```kotlin
// Lines 127-135
private val _routines = MutableStateFlow<List<Routine>>(emptyList())
val routines: StateFlow<List<Routine>> = _routines.asStateFlow()

init {
    viewModelScope.launch {
        routineRepository.getAllRoutines()
            .collect { routinesList ->
                _routines.value = routinesList
            }
    }
}
```

**Dart Implementation:**
```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../data/repositories/routine_repository.dart';
import '../../domain/models/routine.dart';

final routineRepositoryProvider = Provider<RoutineRepository>((ref) {
  throw UnimplementedError('routineRepositoryProvider must be overridden');
});

/// Stream provider for routines
///
/// Ported from MainViewModel.kt routines (lines 127-135)
final routinesProvider = StreamProvider<List<Routine>>((ref) {
  final repo = ref.watch(routineRepositoryProvider);
  return repo.getAllRoutines();
});

/// Actions provider for routine operations
final routineActionsProvider = Provider<RoutineActions>((ref) {
  final repo = ref.watch(routineRepositoryProvider);
  return RoutineActions(repo);
});

class RoutineActions {
  final RoutineRepository _repo;

  RoutineActions(this._repo);

  Future<void> saveRoutine(Routine routine) async {
    await _repo.saveRoutine(routine);
  }

  Future<void> deleteRoutine(int routineId) async {
    await _repo.deleteRoutine(routineId);
  }

  Future<Routine?> getRoutineById(int id) {
    return _repo.getRoutineById(id);
  }
}
```

## 4. Weekly Program Provider

**Kotlin Reference:**
```kotlin
// Lines 137-145
private val _weeklyPrograms = MutableStateFlow<List<WeeklyProgram>>(emptyList())
val weeklyPrograms: StateFlow<List<WeeklyProgram>> = _weeklyPrograms.asStateFlow()

init {
    viewModelScope.launch {
        weeklyProgramRepository.getAllWeeklyPrograms()
            .collect { programs ->
                _weeklyPrograms.value = programs
            }
    }
}
```

**Dart Implementation:**
```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../data/repositories/weekly_program_repository.dart';
import '../../domain/models/weekly_program.dart';

final weeklyProgramRepositoryProvider = Provider<WeeklyProgramRepository>((ref) {
  throw UnimplementedError('weeklyProgramRepositoryProvider must be overridden');
});

/// Stream provider for weekly programs
///
/// Ported from MainViewModel.kt weeklyPrograms (lines 137-145)
final weeklyProgramsProvider = StreamProvider<List<WeeklyProgram>>((ref) {
  final repo = ref.watch(weeklyProgramRepositoryProvider);
  return repo.getAllWeeklyPrograms();
});

/// Actions provider for weekly program operations
final weeklyProgramActionsProvider = Provider<WeeklyProgramActions>((ref) {
  final repo = ref.watch(weeklyProgramRepositoryProvider);
  return WeeklyProgramActions(repo);
});

class WeeklyProgramActions {
  final WeeklyProgramRepository _repo;

  WeeklyProgramActions(this._repo);

  Future<void> saveWeeklyProgram(WeeklyProgram program) async {
    await _repo.saveWeeklyProgram(program);
  }

  Future<void> deleteWeeklyProgram(int programId) async {
    await _repo.deleteWeeklyProgram(programId);
  }

  Future<WeeklyProgram?> getCurrentWeeklyProgram() {
    return _repo.getCurrentWeeklyProgram();
  }
}
```

## Success Criteria

- 4 provider files created
- Each has StreamProvider wrapping repository stream
- Each has Actions class with common operations
- Repository providers use throw UnimplementedError pattern
- Zero compilation errors
- All imports resolved

## Notes

- These are simple wrappers, not complex StateNotifiers
- No state management needed - just pass-through from repository
- Actions classes provide convenient access to repository methods
- All repositories already exist from Phase 3
